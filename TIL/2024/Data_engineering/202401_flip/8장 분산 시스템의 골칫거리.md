> 다음장 부터 보여줄 분산시스템의 보장 알고리즘을 위한, 그동안의 골칫거리들

# 결함과 부분 장애
- 단일 컴퓨터 -> 깔끔하게 지워지고 작성된다. 하드웨어의 연산은 항상 같은 결과를 낸다. : 결정적
- 네트워크로 연결된 다중 컴퓨터 -> 부분 장애 (어떤 부분은 잘 동작하지만 어떤 부분은 예측할 수 없이 고장) : 비결정적

## 클라우드 컴퓨팅과 슈퍼컴퓨팅
- 슈퍼컴퓨터 : 고성능 컴퓨팅. 단일 노드 컴퓨터에 가까움. 부분 장애를 전체 장애로 확대하는 방법으로 처리.
- 클라우드 컴퓨팅 : 멀티 테넌트 데이터 센터, IP (특히 이더넷)으로 연결된 상용컴퓨터 등과 관련
- 전통적인 기업형 데이터센터는 앞선 두 극단의 중간 지점

- 인터넷 서비스 단위에서의 두 컴퓨팅의 차이 (276)
	- 지연시간이 낮은 서비스 제공 (온라인). 클러스터 중단과 같은 전체 프로세스 중단 어려움
	- 하드웨어
		- 슈퍼컴퓨터 : 특화 하드웨어가 필요 
		- 클라우드 : 상용장비로 구축. 낮은 비용이나 높은 실패율
	- 네트워크
		- 슈퍼컴퓨터 : 정해진 HPC 작업부하에서 높은 성능을 보여주는 다차원 메시, 토러스 등의 특화된 네트워크 토폴로지
		- 클라우드 : 높은 양단 대역폭을 제공하기 위한 클로스 토폴로지로의 연결
	- 운영과 유지보수 : 시스템 커질수록 고장날 가능성이 높아진다 
		- 슈퍼컴퓨터 : 결함 복구에 시간 많이 쓸수도 있다
		- 네트워크 : 가상장비 하나 성능이 좋지 않으면 그것을 죽이고 새 가상장비 요청할 수 있다
	- 지리적으로 분산된 배포
		- 네트워크 : 통신은 인터넷을 거치기 쉽다. 로컬에 비해 느리다
		- 슈퍼컴퓨터 : 모든 노드가 가까운곳에 있다고 가정한다.

- 신뢰성 : 결함이 늘 생길 수 있음을 알기
	- 신뢰성 없는 구성요소를 사용해 신뢰성 있는 시스템 구축하기
		- 예) IP : 패킷 누락이나, 지연, 중복, 순서 바뀔 수 있다. -> TCP가 손실된 패킷 재전송, 중복 제거, 패킷 순서 조정하도록 보장
		- 좀 더 신뢰성 있는 상위 수준 시스템 갖추기

# 신뢰성 없는 네트워크
- 책에서의 분산시스템은 비공유 시스템. 저렴하고 클라우드 서비스 이용할 수 있고, 지리적으로 분산된 여러 데이터 센터에 중복 배치함으로써 높은 신뢰성 확보.
	- 비동기 패킷 네트워크. 노드는 다른 노드로 메시지를 보낼 수 있지만 네트워크는 메시지가 언제 도착할지 혹은 메시지가 도착하기는 할 것인지 보장하지 않음. 요청 -> 응답 사이 잘못될 수 있다. (278)
	- 문제를 다루는 흔한 방법 = 타임아웃. 시간이 지나면 응답 대기를 멈추고 도착하지 않았다 가정.

## 현실의 네트워크 결함
- 네트워크 결함 예시~ 
	- 인적 오류 (스위치 설정 오류 등)
	- 소프트웨어 업그레이드
	- 상어가 해저 케이블 물어뜯어서
	- 수신 패킷 누락했는데 송신은 잘보내는 네트워크 인터페이스
- 네트워크 분단 : 네트워크 결함 때문에 일부와 다른쪽 차단되는 것. (네트워크 분리)
-> 소프트웨어가 결함을 처리해야함 -> 복구할 수 있도록 만들기 위해 고의로 문제를 만들어 시스템 반응 테스트 해보기 (카오스 몽키의 기반이 된 생각)

## 결함 감지
- 결함있는 노드를 감지해야 함. (로드 벨런서가 죽은 노드로 요청을 그만보내게 해야하고, 복제를 사용하는 환경에서 리더가 장애가 나면 팔로워중 하나가 리더가 되어야 하니까.) -> 알기 어려움. (281)
	- 수신을 대기하는 프로세스 없다면 TCP 연결 닫거나 거부하면 됨. 근데 노드가 죽으면 실제로 얼마나 처리된건지 알 방법 없다.
	- 노드 프로세스만 죽고 운영체제는 실행중이면, 스크립트로 다른 노드에게 알려 역할 넘겨주기
	- 데이터센터 내 네트워크에 질의 보내 하드웨어 전원 확인
	- 라우터의 장애 감지능력으로 ICMP 패킷으로 응답
- 전달 확인 응답 뿐 아니라 요청을 성공했다는 긍정 응답 필요
- 재시도 해보고 타임아웃 만료 기다렸다가, 응답 없으면 죽었다고 선언

## 타임아웃과 기약 없는 지연
- 그럼 타임아웃의 기준?
	- 길어도 문제 (사용자들은 기다리거나 오류메시지를 보고 있어야하고...)
	- 짧아도 문제 (안된줄 알았는데 사실 되고 있었고, 다른 노드가 넘겨받아서 두번 처리될지도...)
	- 노드가 죽었다고 선언하면 네트워크의 부하가 늘어남 (다른 노드가 넘겨받아야 하니까) -> 그럼 그 부하때문에 느려질수도 -> 다른 연쇄 장애 유발
- 2d(전송 혹은 손실시간 최대치) + r(장애 없는 노드가 처리하는 시간) 시간 내에 응답받는다 보장.
	- 비동기 네트워크는 기약 없는 지연이 있어 이또한 보장 불가
- 네트워크 혼잡과 큐 대기 (282)
	- 여러 노드가 같은 목적지로 보내는 경우 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘겨야 한다. 네트워크 링크가 너무 붐비면 네트워크 혼잡이 발생해 잠시 기다려야할 수 있다. (그림 8-2)
	- 패킷이 목적지에 도착했는데 CPU 바쁘면 기다리게 큐에 넣어둠
	- 가상환경 운영체제 사용시 버퍼링
	- TCP의 흐름 제어. 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한. 데이터가 네트워크에 들어가기도 전에 부가적인 큐 대기를 할 수 있다. ...
- 클라우드, 데이터센터에서 근처에 자원을 많이 쓰는 누군가가 가까이 있다면 네트워크 지연 변동이 클 수 있다. -> 이런 경우에는 타임아웃을 실험적으로 선택.
- 고정된 타임아웃 대신 지속적으로 변동성을 측정하여 자동으로 조절하게 함. (파이 증가 장애 감지기 : 아카와 카산드라)

## 동기 네트워크와 비동기 네트워크
- 패킷 전송 지연시간의 최대치가 고정, 네트워크는 패킷 유실하지 않는 경우가 이상적. -> 하드웨어가 이 문제를 해결할순 없나?
	- 전화 네트워크 : 고정되고 보장된 양의 대역폭 할당. 보장됨. = 동기식, 제한 있는 지연
- 네트워크 지연을 예측 가능하도록? (285)
	- 회선 교환 형식 (고정된 대역폭) <-> 패킷 교환 프로토콜 (큐 대기, 가용한 네트워크 대역폭 사용 -> 기약없는 지연. 순간 트래픽에 최적화 되어있기 때문에)
	- 회선 + 패킷 교환 (하이브리드) : ATM. 서비스 품질과 진입 제어를 잘 쓰면 네트워크에서도 제한 있는 지연 가능. 다만 서비스 품질 어려움... 
	- 결론 : 타임아웃 올바른 값 없음.

# 신뢰성 없는 시계
- 지속 시간 / 특정 시점(이벤트)
- 네트워크 지연때문에 정확한 순서, 시간을 알 수 없음.
- 개별 장비의 각각의 시계 -> 어느정도 동기화할 수 있음 : 네트워크 시간 프로토콜

## 단조 시계 대 일 기준 시계
### 일 기준 시계
- UTC 1970. 1. 1 자정.
- NTP로 동기화. 
- 거친 해상도.
### 단조 시계
- 상대적인 값. = 경과 시간 계산.
- NTP로 진도수 조절은 가능하지만, 앞이나 뒤로 가게 할 수는 없다.
- 해상도 높음.

## 시계 동기화와 정확도
- 하드웨어와 NTP 시계의 차이
	- 컴퓨터의 온도에 따라 수정시간이 변하기도 한다.
	- 컴퓨터 시계와 NTP 서버와 많은 차이가 나면 동기화가 거부되거나 로컬 시계가 강제로 리셋될 수 있다.
	- 방화벽으로 막히는 경우, 패킷 지연의 변화가 큰 네트워크의 정확도 한계 등 문제가 생길 수 있다.
	- 윤초, VM, 사용자가 임의로 시간 바꾸는 등...
- 자원을 투입해 시계 정확도 높이기도 가능. GPS, 정밀 시간 프로토콜 등.

## 동기화된 시계에 의존하기
- 장비 자체에 결함이 있거나 NTP 클라이언트가 잘못 되었다면 시계는 실제 시간과 멀어지지만 미묘한 데이터 손실이 발생
- 이벤트 순서화용 타임스탬프
	- (그림 8-3) 타임 스탬프로 이벤트 순서를 올바르게 정할 수 없는 이유. 최종 쓰기 승리 (LWW)
	- 타음 스탬프를 서버가 아니라 클라이언트에서 생성하는 구현도 있지만 LWW의 문제를 완전 해결하지는 못함 (292)
	- 최근을 유지하고 싶어도 물리적 시계인 일 기준 시계, 단조 시계는 틀릴 수도 있다는 것을 알 것.
- 시계 읽기는 신뢰 구간이 있다
	- 시간을 서버로 부터 얻는다면 불확실성은 
	  서버와 마지막 동기화 시간 이후로 예상되는 시계 드리프트 + NTP 서버의 불확실성 + 네트워크 통신 왕복 시간 -> 알 수 없다.
	- 흥미로운 예외 : 스패너의 구글 트루타임 API. 가능한 타임스템프 범위 중 가장 이른 것과 가장 늦은 것을 가리키는 두개의 값을 받는다.
- 전역 스냅숏용 동기화된 시계
	- 스패너의 스냅숏 격리 구현
		- 타임스탬프 두 구간이 겹치지 않는다면 순서를 확신할 수 있음
		- 의도적으로 신뢰 구간의 길이만큼 기다린다. -> 겹치지 않는다.

## 프로세스 중단
- 파티션마다 리더가 있고, 그 리더만 쓰기를 받아들이도록 허용. 노드가 여전히 리더인지, 안전하게 쓰기를 받아들일 수 있을지 어떻게 알 수 있을까?
	- 임차권(lease). 주기적으로 갱신
	- 스레드가 아주 오래 멈춘 경우이면서 리더가 임차권이 만료되었음을 알지 못할 때 안전하지 않을수도 있다. 
		- 스레드가 아주 오랫동안 멈춘 경우 (296~297)
- 응답시간 보장
	- 운영체제 스레드와 프로세스가 기약없이 중단될 때 원인을 제거하는 방법
		- 실시간 운영체제 : 소프트웨어 스택의 모든 수준에서, 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케줄링. 막대한 양의 테스트와 측정 (고비용) -> 적절하지 않다.
- 가비지 컬렉션의 영향을 제거하기
	- GC 중단을 계획적이라고 간주하고, 노드가 가비지 컬렉션을 하는 동안 클라이언트로부터의 요청을 다른 노드들이 처리하게 하기
	- 수명이 짧은 객체만 GC를 사용하고 수명 긴 객체의 GC가 필요할만큼 쌓이기 전에 주기적으로 프로세스 재시작


# 지식, 진실, 그리고 거짓말
- 분산 시스템의 경우, 네트워크 문제와 노드 문제를 확실히 구별하기 힘들다
- 시스템 모델의 가정을 명시하고 이를 만족시키는 방식으로 실제 시스템을 설계.
	- 시스템 모델에서 잘 동작할 수 있게, 몇가지 가정과 보장의 종류에 대해 생각해볼 수 있는 방법들을 후술.

## 진실은 다수결로 결정된다
- 노드 자신이 판단을 못하는 경우
	- 자신에게 보내지는 메시지는 받을 수 있지만, 나가는 메시지는 유실되거나 지연되어 자신이 끊긴지 모르는 상황
	- 자신의 메시지가 다른 노드로 확인받지 못한 것을 안 상황
	- 노드가 GC 중단으로 멈췄다가 죽은것으로 선언되었는데 재실행되는 상황
	- => 특정 노드 하나에 의존하지 않도록, 노드가 죽었다고 선언하는 것에 대한 정족수 필요

- 리더와 잠금
	- 분산시스템에서 선택된 자 노드가 있을 때 주의할 것. -> 노드의 과반수가 죽었다고 선언한 노드가, 선택된 자인 것 처럼 행동한다면 문제가 생길 수 있음. (그림 8-4) 
	- 선택된 자라고 잘못 믿는 노드가 나머지를 방해하지 않도록 하는 방법 : 팬싱 토큰 (그림 8-5)

## 비잔틴 결함
- 노드가 거짓말을 한다면? (임의의 결함이 있거나 오염된 응답을 보냄) = 비잔틴 결함
	- 비잔틴 장군 문제 : 두 군대의 장군이 전투 계획에 동의해야 함. 전령을 통해서 연락하고 때때로 늦거나 실종될 수 있다. n명의 장군이 동의해야 하며 그들의 노력은 배신자가 있다는 사실에 방해를 받는다. 누가 배신자인지 알려지지 않는다.
	- 거짓말을 하는 중(오작동하고, 프로토콜 준수하지 않고, 악의적 공격자가 네트워크를 방해하는 중)에도 계속 올바르게 동작한다면 "비잔틴 내결함성"을 지닌다고 함. 비잔틴 내결함성 솔루션은 비용이 커서 실용적이지는 않다.
	- 전통적인 메커니즘(인증, 접근 제어, 암호화, 방화벽 등)이 공격자로부터 보호하는 수단으로 사용되고 있음.
- 약한 형태의 거짓말
	- 하드웨어 문제, 소프트웨어 버그, 잘못된 설정 때문에 유효하지 않은 메시지 등
	- 소프트웨어에 보호할 수 있게 추가하는 것이 좋은 방법일 수 있다.

## 시스템 모델과 현실
- 시스템 모델 : 알고리즘이 가정한 것을 기술한 추상화
	- 동기식 모델 : 네트워크 지연, 중단, 시계 드리프트가 고정된 상한치(제한)를 초과하지 않을 것임을 앎.
	- **부분 동기식 모델 : 대부분의 시간에는 동기식. 때때로 문제가 생김**
	- 비동기식 모델 : 타이밍에 대한 어떤 가정도 없음.
- 노드 장애시 활용하는 시스템 모델
	- 죽으면 중단하는 결함 : 노드 장애시 영원히 사용할 수 없고 되돌아 오지 않음
	- **죽으면 복구하는 결함 : 노드 장애시 시간이 흐른 후 다시 응답. (메모리는 손실되지만 저장소는 복구 할 수 있음)**
	- 비잔틴(임의적인) 결함 : 다른 노드를 속이거나 기만하는 것을 포함해 무슨일이든 할 수 있다.

### 분산 알고리즘에서 고려해야할 요소들
- 알고리즘의 정확성
	- = 속성에 맞는 대로 진행 되는 것. 속성을 만족시키면 해당 시스템 모델에서 정확하다고 할 수 있음
	- -> 모든 노드가 죽거나, 네트워크 지연이 무한히 길어진다면 어떤 알고리즘이라도 아무것도 할 수 없다.
- 안정성과 활동성
	- 안전성 : 나쁜일은 일어나지 않는다. 위반되면 속성이 깨진 그 시점을 알 수 있다. 위반을 취소할 수 없다.
	- 활동성 : 좋은일은 결국 일어난다. 위반되면 시점은 몰라도, 미래에 그 속성을 만족시킬 수 있다. 
	- 두가지 개념을 구별하면 시스템 모델을 다루는데 도움이 된다. 안전성은 항상 만족시키는 것이 일반적이고 활동성은 경고가 가능하다.
- 시스템 모델을 현실세계에 대응시키기
	- 추상 시스템 모델로 현실의 복잡함을 이해할 수 있게 미리 설계함
	- 시스템 모델에서 알고리즘의 정확성과, 안정성-활동성을 이해하고 구현한다면 시스템에서 알고리즘을 구현할 때 도움이 됨. (무조건 올바르게 동작한다는 것은 아님!)


# 정리
- 분산시스템은 부분 실패가 발생할 수도 있다.
- 이 결함을 이해하기 위해 감지하는 것이 중요한데, 어렵다.
- 노드 장애를 알기위해 타임아웃 사용
	- 성능이 저하된건지, 장애인건지는 알 수 없다. 
- 결함이 발견되었을 때 시스템이 견디는 방법으로 정족수를 이용하는 내용도 있었다.
- 엄격하게 신뢰성을 갖추려는 시도는 가능하지만, 비싸다. 그래서 저렴하고 신뢰성이 없는 것을 택한다.
- 문제가 발생하는 다양한 경우에 시스템 중단 없이 계속 실행할 수 있는 이론적인 부분에 대해서 이야기했다. 다음장에서는 해결책으로 옮겨가 분산 시스템의 모든 문제에 대처하도록 설계된 알고리즘을 살펴본다.


