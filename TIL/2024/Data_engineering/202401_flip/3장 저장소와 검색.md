
# 데이터베이스를 강력하게 만드는 데이터 구조
- 로그 : 추가 전용 레코드

## 해시 색인
- 색인 : 기본 데이터에 추가적인 구조를 포함
	- 추가시 기본 데이터에 영향을 미치지는 않으며, 질의 성능에 영향을 미침
	- 쓰기 속도 느리게 만들고(색인 갱신) 읽기 속도 빠르게 만듦.
	- ! Json : jin index
- 해시 색인 : 해시맵(해시테이블)을 이용하는 색인 방법
	- ! RDBMS에서 해시의 해시와 다른개념. 해시 조인을 사용하기도 한다.
	- 인메모리 해시 맵 
	- 언제 쓰나 ? 자주 갱신될 때 (비트캐스크 저장소 엔진과 같은)
	- 방식 : 계속 추가해서 쓰는 형식 -> 모든 키를 보관 -> 디스크 부족할 수 있음 -> 세그먼트로 로그 분리 -> 컴팩션을 수형 (중복 키는 버리고 최신 값만 남기기)
		- 컴팩션 : 세그먼트들을 합쳐서 중복 버리기. 두 세그먼트를 합치는 경우 다른 세그먼트를 만들어서 최신것만 낢기고 옮기고 나서 지우기. (충돌 없을듯)
	- 구현에서 중요한 문제 : 파일 형식 바이너리가 좋음, 키와 관한 값을 지우려면 특수한 삭제 레코드를 추가해야함. 스냅숏 저장해 다시 복구할 때 편하게, 부분적으로 레코드 쓰기, 쓰기는 하나의 쓰레드만 읽기는 다중 읽기 가능
- (추가전용의) 장점 : 빠르다, 동시성과 고장 복구 간단하다 (파일 남겨둠).
- 단점 (제한사항) : 키가 많으면 문제가 됨. 무작위 접근 I/O가 많이 일어남, 디스크 확장 비쌈, 충돌해소를 위한 로직을 짜야함

! spark : scala언어 기반으로 만든 분산 컴퓨팅 엔진


## SS테이블과 LSM 트리
- SS테이블 : 정렬된 문자열 테이블
- 세그먼트 과정 (병합정렬 방식과 유사)
	- 각 파일의 정렬된 순서에 따라 첫번째 키를 보고 비교, 같은것 중에 가장 최신것을 옮겨 입력
### SS테이블  생성과 유지
- 디스크에 구조를 유지하는것? 가능, 메모리에 유지하는 것? 쉬움
- 키를 삽입할 때는 임의로, 읽을 때는 정렬된 상태로
- SS테이블의 저장소 엔진의 데이터 축적-관리 순서
	- 쓰기가 들어오면 인메모리 트리 (멤테이블)에 추가한다
	- 멤테이블이 어느 임계값보다 커지면 SS테이블 파일로 디스크에 기록한다. (기록하는 동안 새로운 멤테이블 인스턴스에 추가되는중)
	- 찾기가 들어오면 우선 멤테이블에서 키를 찾고, 없으면 디스크에서 찾는다. 점점 오래된 디스크로
	- 가끔 병합 컴펙션 과정을 백그라운드로 수행한다.
### SS테이블에서 LSM 트리 만들기
- LSM 트리 : 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진
	- 루씬 (엘라스틱서치나 솔라에서 사용)
### 성능 최적화
- 존재하지 않는 키를 찾는데 오래걸림 -> 블룸 필터 사용 
- SS테이블 압축병합하는 순서 시기를 결정하는 전략 : 크기 계층 컴팩션, 레벨 컴팩션


## B트리
- 고정 크기의 블록과 페이지로 만들어놓고 하나의 페이지에 읽기 또는 쓰기를 한다.
- 트리의 루트로 지정된 페이지가 있고 224번을 찾으려고 하는 상황에서 -> 그 아래로 키 200~300 안으로 -> 그 아래 200~250 -> 200~225 ...  이렇게 길 따라 간 횟수를 분기 계수라고 한다.
- O(log n)
### 신뢰할 수 있는 B트리 만들기
- 페이지 덮어씌우기가 기본 쓰기 동작임. 
- 복구하려면 쓰기 전 로그라고 하는 데이터 구조를 추가. 복원하는데 이용
- 동일 페이지에서 갱신하려면 동시성 제어를 주의깊게 해야함. 래치(가벼운 잠금)을 걸어 트리의 데이터 구조를 보호한다. (! 트렌젝션이랑 다른 개념이다. 물리적으로 잠그는 것)
### B트리 최적화
- WAL을 유지하는 대신 쓰기 시 복사 방식(copy-on-write sckeme)을 사용
- 키를 축약해 사용
- B트리 리프 페이지를 디스크상 연속된 순서로 나타나게끔 트리 배치를 시도
- 트리에 포인터 추가
- 프렉탈 트리와 같은 트리 변형 사용

## B트리와 LSM 트리 비교
- 일반적으로 B트리 읽기 빠름, LSM트리 쓰기 빠르다고 알려져 있음
### LSM 트리의 장점
- 쓰기:  B트리 = 쓰기 좀 느림: 데이터 기록을 두번은 해야함 (쓰기 전 로그, 트리 페이지), 몇 바이트만 바꿔도 전체 페이지 바꿔야하는 오버헤드도 존재. <-> LSM은 쓰기 빠름
	- 쓰기가 많은 애플리케이션에서는 쓰기 증폭이 성능 비용이다.
		- 자기 하드 드라이브에서 훨씬 중요. 순차가 빠르기 때문에.
- 압축률: B트리 보다 LSM트리가 더 적은 파일을 생성한다. 저장소 오버헤드가 낮다. (레벨 컴펙션을 사용하면 특히 그렇다)
+ 낮은 쓰기 증폭과 파편화 감소가 SSD에서 훨씬 유리하다.
### LSM 트리의 단점
- 컴팩션에서 읽기 쓰기 성능에 영향 : 동시 접근 못하게 하지만 디스크 자원의 한계로 컴팩션 연산을 하는동안 대기하는 일이 있다. (예측이 어렵다. B트리는 예측이 좀 수월)
- 컴펙션에서 쓰기 성능 영향 : 데이터베이스가 커질수록 컴펙션을 위해 더 많은 디스크 대역폭이 필요하다. 속도 못따라갈수 있다. 명시적 모니터링이 필요하다.
- 같은 키 다중 복사본이 있을 수 있다.
	- 그래서 강한 트랜잭션 시맨틱을 제공하는 DB는 B트리(! 락이 걸리기 때문에~) 사용하는 것이 유리.
- ! SLA (서비스를 ㅈㅔ공하면서 응답하는 시간)
## 기타 색인 구조
- 보조 색인 사용(기본키를 가르키는 방향으로 있다)
### 색인 안에 값 저장하기
? 힙파일 색인 안에다 값을 저장, 갱신하는 것
! 클러스터드 색인 (전화번호부) , 비클러스터드 색인 (책에 맨 뒤 부록에 가는 방향 나오는 것)
! 커버링 색인 : 
! 인클루드 컬럼 색인 : 컬럼에 색인 값도 다 넣어버림
### 다중 컬럼 색인
- 결합 색인 (RGB, 날짜-기온 등 여러 컬럼을 조합하여 검색)
### 전문 검색과 퍼지 색인
- fuzzy (애매모호한)  => edit distance 등으로 단어간 거리 검색 (오타 고려)
### 모든 것을 메모리에 보관
- ! Radis
- 인메모리 데이터 베이스
- 사용하지 않는 것을 디스크로 보내고 다시 접근할 때 메모리에 적재하는 방식을 사용하기 도함 (안티캐싱)

---
# 트랜잭션 처리나 분석?
- 트랜잭션 : 일반적으로 ACID로 알려져 있으나, 주기적으로 수행되는 일괄 처리 작업과 다르게 클라이언트가 지연 시간이 낮은 읽기와 쓰기를 가능하게 한다는 의미이다.
- 온라인 트랜잭션 처리 / 온라인 분석 처리는 다른 개념

## 데이터 웨어하우징
- 분석 질의는 비용이 바쌈
- 그래서 데이터 웨어하우스를 만들어 놓음. 개별 데이터베이스
- 추출 분석친화적으로 변환, 적재 하여 ETL을 수행
	- ETL
	- 데이터 웨어하우스 > 데이터 마트
### OLTP 데이터베이스와 데이터 웨어하우스의 차이점
- 둘은 매우 다른 질의 패턴에 맞게 최적화 되었기 때문에 시스템 내부가 다르다. 
- 이제 둘 중하나를 지원한는 데 중점을 둔다.
## 분석용 스키마 : 별 모양 스키마와 눈꽃송이 모양 스키마
- 개별 이벤트 별로 사실 테이블을 만든다. -> 다른 테이블을 가르키는 외래키 참조를 이용

---
# 칼럼 지향 저장소
## 칼럼 압축
### 메모리 대역폭과 벡터화 처리


## 칼럼 저장소의 순서 정렬
### 다양한 순서 정렬


## 칼럼 지향 저장소에 쓰기


## 집계: 데이터 큐브와 구체화 뷰

---


-  AWS 컴퓨팅을 쓰고 Bigquery를 안에 넣어 사용하기도 함
- 