## 2단계 데이터 저장

---

## 6.1 데이터 스토리지의 기본 구성 요소

### 6.1.1 자기 디스크 드라이브 (HDD)

- SSD보다 저렴하고 대용량 저장에 적합함
- 읽기/쓰기 헤드가 디스크의 특정 위치로 이동한 후 데이터를 기록하는 방식이라 속도가 느림
- 여러 디스크에 데이터를 분산 저장해 병렬로 읽는 방식으로 속도 문제를 완화함

### 6.1.2 SSD (Solid State Drive)

- HDD보다 비싸지만(10배), 훨씬 뛰어난 전송 속도와 낮은 지연 시간을 제공함
- SSD를 캐싱에 활용해 고성능 쿼리 지원하여 성능 향상

### 6.1.3 임의 접근 메모리 (RAM)

- 휘발성이며 장애 발생 시 데이터가 손실됨
- SSD보다 약 1000배 빠르지만 매우 고가임
- CPU 캐시 용량이 부족할 경우 RAM을 캐시 계층으로 활용함
    - CPU 캐시는 더 빠르지만 용량이 매우 작고, RAM은 조금 느리지만 훨씬 큰 용량을 제공함

### 6.1.4 네트워킹과 CPU

- 클라우드 객체 스토리지 클러스터에서는 네트워크를 통해 디스크를 분산 구성함
- 물리적 위치를 분산 저장해 병목을 줄이고 내구성과 가용성을 높임

### 6.1.5 직렬화 (Serialization)

- 데이터를 저장하거나 전송하기 위해 바이트 스트림 등 일정한 포맷으로 변환하는 과정
- 직렬화는 데이터 구조를 JSON, Parquet 같은 포맷으로 ‘포장’하는 과정임. 반대로 포맷을 원래 데이터 구조로 되돌리는 건 역직렬화(디코딩)임
- 데이터 엔지니어는 일반적인 직렬화 관행에 익숙해질 것을 권장함

### 6.1.6 압축 (Compression)

- 파일 크기를 줄여 디스크 사용량과 네트워크 전송량을 줄임
- 압축률이 높으면 전송 데이터가 줄어 네트워크 속도가 개선됨. 대신 압축/해제 과정에 CPU 연산 비용이 추가됨

### 6.1.7 캐싱 (Caching)

- 속도, 비용, 용량 간의 상관관계를 고려해 디스크보다 빠른 계층(RAM 등)에 데이터를 임시 저장하는 기술
- 자주 접근하는 데이터는 비싸고  빠른 스토리지에 저장하고, 접근 빈도가 낮은 데이터는 더 저렴하고 느린 스토리지에 저장함
- EX) 자주 조회 되는 상품 목록을 DB 대신 Redis에 저장해 매번 디스크에서 읽는 대신 메모리에서 바로 제공하면 응답 속도 향상, DB 부하 감소, 비용 절감 효과가 있음
        
- 역 캐시: 보관 스토리지의 경우 데이터 백업 및 데이터 보존 컴플라이언스 요건 충족하는데 사용 (비상시에 사용)

---

## 6.2 데이터 스토리지 시스템

스토리지 시스템은 기본 구성 요소 이상의 추상화 수준에 존재

### 6.2.1 단일 머신 vs 분산 스토리지

- 단일 머신: 단순하지만 확장성과 내구성이 떨어짐
- 분산 스토리지: 여러 서버에 분산 저장해 성능과 안정성을 높임

### 6.2.2 최종 일관성 vs 강력한 일관성

- 분산 시스템에서 데이터 일관성을 어떻게 유지할 것인가?
    - 데이터가 여러 복제본에 퍼져 있으니, 변경사항이 모든 복제본에 동기화되기 전까지는 불일치가 생김
- **일관성 패턴**
    - **최종 일관성**:
        - 시간이 지나면 모든 노드가 최신 데이터로 수렴.  읽기 시점에 불일치 가능
        - 빠르게 검색 가능
    - **강력한 일관성**:
        - 언제 읽어도 동일한 최신 상태를 보장
        - 지연 시간이 길어짐, 더 많은 리소스 사용함
- 강력한 일관성은 일반적으로 비용이 2배 가량 더 들 수 있음. 일단 최종 일관성을 위주로 하고 옵션으로 강력한 일관성을 제공하는 경우도 있음

### 6.2.3 파일 스토리지

- 디렉토리 계층 구조 기반
- 저장 시 영구적이지만, 쓰기 중 장애 발생 시 해당 데이터는 손실됨
- 네트워크 활용 시 NAS 형태로 제공됨

### 6.2.4 블록 스토리지

- 데이터를 블록 단위로 나눠 저장
    - 블록: 디스크에서 지원하는 주소 지정이 가능한 최소 데이터 단위
- 블록 정보만 있으면 다른 서버에 저장돼도 접근 가능
- 사용 방법: RAID, SAN, 클라우드 가상화 블록 스토리지, 로컬 인스턴스 볼륨, 하둡

### 6.2.5 객체 스토리지

- 데이터를 객체 단위로 저장
    - 객체: CSV, 이미지, JSON, 오디오, 비디오 등 특수한 파일 구조
- 대표적인 객체 스토리지
    - AWS S3: 키-값 형태 저장, 불변성 특징
        - 불변성: 객체는 한번 쓰이면 변경되지 않고 변경 및 추가 하려면 다시 작성해야 함
- 대규모 배치 읽기/쓰기 성능이 좋아 OLAP에 적합
    - OLTP: 은행 **계좌 입출금 시스템,** 온라인 쇼핑몰의 **주문·결제 처리**
        - 매 순간 수많은 트랜잭션이 발생하고, ACID(원자성, 일관성, 고립성, 지속성)를 보장해야 함.
    - OLAP: **매출 분석 대시보드, 재무 분석 리포트**
        - 데이터 웨어하우스(DW) 또는 데이터 마트에 저장된 과거 데이터를 집계·분석
- 데이터 레이크의 스토리지 표준이 됨

---

### 6.2.6 캐시 및 메모리 기반 스토리지 시스템

- 자주 호출되는 데이터를 임시로 저장해 캐싱에 활용하는 파일시스템
- RAM: 속도 빠르지만 휘발성
- 예: Redis, Memcached

---

### 6.2.7 하둡 분산 파일시스템 (HDFS)

- 대규모 데이터를 여러 서버에 분산 저장하는 파일시스템
- 데이터 블록을 여러 노드에 복제해 내구성 확보
- 대규모 배치 처리에 최적화됨

---

### 6.2.8 스트리밍 스토리지

- 연속 데이터 처리용 저장하고 전달하는 파일시스템
- 카프카(Kafka), 아마존 키네시스(Kinesis) 등 스트리밍 프레임워크 사용
- 실시간 데이터 처리뿐 아니라 장기 데이터 보존 가능
- 과거 시점으로 돌아가 데이터 재처리(리플레이) 가능
    - 예전에 발생했던 스트리밍 데이터를 저장 했다가 그 시점부터 다시 읽어서 처리 가능함
    - 예를 들어,
    1. 8월 10일~8월 12일에 들어온 주문 데이터가 있음
    2. 8월 13일에 집계 로직에서 버그 발견
    3. Kafka에서 8월 10일 00시의 offset부터 다시 읽어서 **정상 로직으로 재집계** 가능
- 특정 시간 범위에 걸친 배치 처리 가능

---

### 6.2.9 인덱스, 파티셔닝 및 클러스터링

- 대규모 데이터 환경에서 데이터 접근 성능을 높이기 위한 핵심 기술
    - 인덱스: 특정 컬럼 기반 빠른 검색 지원
    - 파티셔닝: 데이터를 범위, 해시, 리스트 등 기준으로 물리적으로 분할해 불필요한 데이터를 제외
    - 클러스터링: 데이터를 물리적으로 정렬해 저장해 필터링 조인 성능 향상
- 스노우 플레이크처럼 **마이크로 파티션 + 메타데이터 관리**를 활용하면 쿼리 최적화 가능

---

## 6.3 데이터 엔지니어링 스토리지 개요

### 6.3.1 데이터 웨어하우스

- 표준 OLAP 데이터 아키텍처
- 텍스트 데이터, JSON 등 처리 가능하지만 이미지, 오디오는 불가
- 예시: Snowflake, Google BigQuery, Amazon Redshift

### 6.3.2 데이터 레이크

- 가공되지 않은 원시 데이터 저장
- 클라우드의 발달로 장기 보존 개념으로 HDFS를 다른 것으로 대체 →  데이터 레이크하우스의 근간이 됨
- 예시: Hadoop HDFS
- 창고에 원재료를 직접 쌓아두고 창고 관리 확장까지 직접함

### 6.3.3 데이터 레이크하우스

- 데이터 웨어하우스 + 데이터 레이크 개념 결합
- 외부 대형 창고 서비스에 원재료를 맡기고 필요할 때 꺼내쓰는 개
- 객체 스토리지에 다양한 형태 데이터 저장 가능
    - 예시: AWS S3 + Glue + Athena, Azure Data Lake
    - HDFS 대신 S3 같은 데이터 레이크를 장기 저장소로 사용하고, Spark,Flink,Hive 등이 직접 이 스토리지를 읽음.
- OLAP 쿼리를 지원해 분석 속도 확보
    - OLAP 쿼리: 분석용 쿼리(집계, 통계, 필터링 등) 수행에 최적화된 조회 방식

### 6.3.4 데이터 플랫폼

- 다양한 데이터 소스와 스토리지, 처리 엔진을 통합 관리하는 환경
    - 데이터 소스: DB,  로그, 센서데이터
    - 스토리지: DW, Data Lake
    - 처리 엔진: Spark, Flink, Kafka
    - 예시:
        - 오픈소스 형: Apache Airflow + Hive + Spark + Kafka
        - 클라우드 형: AWS Glue + Athena + S3 + QuickSight

### 6.3.5 Stream-to-Batch 스토리지 아키텍처

- 실시간 수집된 스트리밍 데이터를 버퍼에 저장 후, 컬럼형 객체 스토리지로 전환
    - 실시간 수집: Kafka, Flink, Kinesis 로 데이터가 계속 들어옴
    - 버퍼 저장: 메모리나 임시 디스크에 짧게 보관함
        - 스트리밍 데이터는 일정 단위로 모아야 효율적으로 저장 가능
    - 컬럼형 객체 스토리지로 전환
        - 컬럼 지향(Column-oriented) 저장 – Parquet/ORC 구조
            - EX)
            
            Column "user_id": [1, 2, 3]
            Column "age":     [25, 30, 22]
            Column "country": [KR, US, JP]
            
            특정 컬럼을 읽는 경우 훨씬 빠르고 압축 효율이 높은 장점이 있음
            
        - 객체 스토리지 : 싸고 안전하고 확장 가능하며 이후 분석 도구들이 바로 읽을 수 있음
    - 이 후 배치 분석: Spark, Athena 같은 OLAP 엔진이 읽어서 분석함
- 람다 아키텍처와 유사하지만 동일 플랫폼 내에서 처리 가능
    - 람다 아키텍처는 배치와 실시간이 서로 다른 시스템이라 복잡하지만, 최근에는 Flink의 경우에도 스트리밍 처리와 배치 저장을 별도 시스템 없이 운영 가능

---

## 6.4 스토리지의 주요 아이디어와 동향

### 6.4.1 데이터 카탈로그

- 조직의 데이터에 대한 중앙 집중식 메타데이터 저장소
- 데이터 계보(Lineage)와 관계 표현 가능하면 좋음
- API를 통해 메타데이터 갱신 가능하면 좋음
- 데이터 레이크, 웨어하우스, DB 메타데이터 자동 수집하면 좋

### 6.4.2 데이터 공유

- 조직 내/외부에서 데이터셋을 안전하게 공유하는 방식 채택

### 6.4.3 스키마

- 데이터 구조와 형식을 정의하는 규칙
- 쓰기 스키마
    - 저장 전에 데이터 형식·구조를 엄격히 검증
    - 장점: 데이터 품질 보장, 쿼리·분석 시 안정성 높음
    - 단점: 유연성 떨어짐, 신규 데이터 형식 수용이 느림
    - 데이터  웨어하우스에서 주로 사용
- 읽기 스키마
    - 저장 시 형식 제한 없이 원본 그대로 보관
    - 읽을 때 변환·검증
    - 장점: 유연성 높음, 다양한 원본 데이터 수용 가능
    - 단점: 분석 시 품질, 정합성 관리가 어려움
    - 데이터 레이크에서 주로 사용

### 6.4.4 컴퓨팅과 스토리지의 분리

- 스토리지와 컴퓨팅을 따로 운영할 수 있음
    - EBS처럼 스토리지를 가상화해 컴퓨팅과 분리
        - EBS: AWS에서 제공하는 클라우드 블록 스토리지 서비스
- 필요할 때만 컴퓨팅 리소스를 띄우고 작업 후 삭제 가능
- 분리 구조에선 얕은 복사(무복사)와 깊은 복사 모두 지원
    - 얕은 복사: 데이터를 물리적으로 복제하지 않고, 같은 저장 위치를 참조
    - 깊은 복사: 데이터를 물리적으로 복제

### 6.4.5 데이터 스토리지 수명 주기 및 데이터 보존

- 데이터 접근 빈도에 따라 스토리지 계층을 구분
- **핫 스토리지**: 자주 접근, 비용 높지만 검색 비용 낮음
- **웜 스토리지**: 월 1회 정도 접근, 중간 비용
- **콜드 스토리지**: 분기/연 1회 접근, 저장 비용 낮지만 검색 비용 높음

---

## 6.5 함께 작업할 대상

- 데이터 과학자, 분석가, 인프라 엔지니어, 보안 담당자 등과 협업 필요

---

## 6.6 드러나지 않는 요소

- **보안**: 암호화, 접근 제어, 감사 로그
- **데이터 관리**: 품질, 메타데이터, 거버넌스
- **데이터 옵스**: 데이터 파이프라인 운영 자동화
- **데이터 아키텍처**: 시스템 간 데이터 흐름 설계
- **오케스트레이션**: 워크플로 자동화(Airflow 등)
- **소프트웨어 엔지니어링**: 모듈화, 테스트, 형상 관리

---

## 6.7 결론

- 스토리지 설계는 성능, 비용, 내구성, 가용성의 균형을 맞추는 작업
- 데이터 특성과 사용 패턴에 맞는 저장 구조 선택이 핵심
