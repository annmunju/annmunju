
# 견고한 데이터 엔지니어링
## 8장 요약 (1)

> 쿼리 모델링


# 8.1 쿼리

## 8.1.1 쿼리란 무엇인가

- DDL : Create, Drop, Alter
- DML : Select, Insert, Update, Delete, Copy, Merge
- DCL : Grant, Deny, Revoke
- TCL : Commit, Rollback


## 8.1.2 쿼리 수명

1. 쿼리 명령어 수행
2. 파싱 및 바이트코드로 변환
3. 쿼리 플래닝과 최적화
4. 쿼리 실행
5. 결과 반환


## 8.1.3 쿼리 옵티마이저

> 쿼리를 효율적인 순서로, 적절한 단계로 분할해 쿼리 서능을 최적화하고 비용을 최소화

## 8.1.4 쿼리 성능 향상

### 1) 조인 전략 및 스키마 최적화
- 선 조인을 통해서 쿼리를 읽기
- 자주 조인되는 데이터를 반정규화 해서 테이블 만들어두기
- 379p 많은 행 지향 데이터베이스에서는 행에서 계산된 결과를 인덱싱 할 수 있다. ... 
조인을 위해 새로운 파생 열 만들지 말고 lower() 함수 표시되는 해당 행에 인덱스를 적용해서 join 하기


- 행 폭발
    - join을 반복 연산하면서 생기는 문제. 쿼리 실패 혹은 대량의 데이터베이스 리소스 소비
    - 쿼리 옵티마이저 별 조인 처리 방식이 다르다.
        - 어떤건 조인과 조건절 순서를 변경할 수 있기도 함.
    - 조건절 재정렬을 통해 쿼리에 필요한 연산 리소스를 줄이자.
- 중첩된 서브 쿼리 또는 공통 테이블 표현식 CTE 사용하기
    - 가독성을 높여줌
    - 중간 테이블 작성 스크립트보다 성능 좋음
    
```sql
WITH cte_name (column1, column2, ...) AS (
    -- CTE 정의 SQL
    SELECT column1, column2, ...
    FROM table_name
)
SELECT column1, column2, ...
FROM cte_name
WHERE condition;
```


### 2) 실행 계획을 사용한 쿼리 성능 파악
- 쿼리 옵티마이저를 사용하는 DB는 쿼리 단계에서 자원 소비와 성능 통계를 보여줌
- 이게 없는 경우 EXPLAIN 명령을 사용해 실행 계획을 알도록 한다.
- 모니터링 필요 영역
    - 주요 리소스 사용량
    - 데이터 로딩 시간 및 처리 시간 비교
    - 쿼리 실행 시간, 레코드 수, 스캔한 데이터 크기 등

### 3) 전체 테이블 스캔 방지
- Select * -> 전체 스캔되니 사용하지 말기
- 가지치기 Pruning 를 사용해 쿼리에서 스캔되는 데이터 양을 지우기
    - 열 지향 (필요한 열만 선택하기) vs 행 지향 (인덱스 활용)


### 4) 데이터베이스가 커밋을 처리하는 방법 파악
- 트랜잭션: 여러 작업을 동시에 커밋하는 개념. 모두 일관된 데이터베이스 상태를 유지하도록 해줌.
- ACID를 준수하는 데이터베이스인지? 그렇지 않은 데이터베이스인지? 
- 더티 리드 : 행을 읽을 시점에, 커밋되지 않은 트랜잭션이 행을 변경할 경우. -> 어떻게 대처해야할지?
- 갱신 및 삭제 트랜잭션 중 데이터베이스 새 상태를 나타내는 새 파일을 작성하고, 실패 체크포인트 참조를 위해 이전 파일을 유지하는 등. 작은 커밋을 실행하며 스토리지 공간을 소모하는 경우도 있음.


- DB 별 커밋 처리 방법 (1)
    - PostgreSQL : ACID 트랜잭션 적용을 위해서 행 잠금이 필요. -> 대규모 스캔이나 분석시에 성능이 저하될 수 있음
    - 빅쿼리 
    	- 풀 테이블 커밋 모델: 테이블에 변경(쓰기)이 있을 때마다 빅쿼리는 커밋된 새로운 버전(스냅숏)을 만듦. 즉, 테이블은 시간순으로 여러 버전을 갖게 됨
        - 쿼리 실행 시점: 사용자가 쿼리를 시작하면, 빅쿼리는 쿼리를 시작한 시점의 최신 스냅숏을 기준으로 데이터를 읽음 -> 쿼리가 오래 걸리더라도 실행이 끝날 때까지는 그 시점의 데이터만 읽고, 이후에 들어온 새로운 데이터는 보이지 않음
        - 후속 쓰기 작업: 쿼리가 실행되는 동안 다른 사용자가 테이블에 데이터를 추가/수정하더라도, 이미 실행 중인 쿼리는 영향을 받지 않음 -> 대신 새로운 데이터는 새로운 커밋/스냅숏으로 저장되고, 이후에 실행되는 쿼리에서부터 반영
        - 한번에 하나의 쓰기 작업만 혀용. 쓰기 동시성 없음. 
        - 스노플레이크, 스파크 등의 커밋 모델과 유사


- DB 별 커밋 처리 방법 (2) 
    - 몽고DB : 뛰어난 확장성과 쓰기 동시성 -> 트래픽 과부하 발생시 쓰기를 폐기

### 5) 배큠 데드 레코드
- 배큐밍 : 오래된 레코드 정리하기
- 새로운 레코드 저장 공간 확보해 테이블 크기도 줄이고 쿼리도 빠르게 수행
- 부정확한 플랜을 생성하는 오래된 레코드 제거
- 데이터 베이스 유형에 따라 다르게 처리하기
    - 객체 스토리지 기반 DB는 테이블 스냅숏 기간(스노우플레이크)/이력 윈도 기간(빅쿼리) 를 통해 자동으로 정리됨. 혹은 수동 베큠 수행(데이터브릭스)인 경우도 있음.
    - 관계형 DB는 빠르게 데드 레코드 축적될 수 있으므로 엔지니어가 해당 영향을 판단해 작업해야함.


### 6) 캐시된 결과 활용
- 자주 실행되는 쿼리를 저장해두기.
- OLAP 데이터베이스에서 주로 사용.
- 구체화된 뷰와 비교

| 구분       | 구체화된 뷰 (MV)                 | 쿼리 캐시                     |
|------------|----------------------------------|--------------------------------|
| 저장 위치  | 물리적으로 테이블처럼 저장        | 시스템 내부 캐시에 임시 저장   |
| 지속성     | 데이터베이스에 남음              | 일정 시간 후 소멸/무효화       |
| 업데이트   | 수동/자동 리프레시 필요           | 데이터 변경 시 무효화          |
| 사용 목적  | 반복적인 무거운 집계 쿼리 최적화 | 짧은 시간 내 동일 쿼리 최적화  |
| 공간 사용  | 별도 저장공간 필요               | 별도 공간 거의 없음            |


## 8.1.5 스트리밍 데이터에 대한 쿼리

### 1) 스트림에서 기본 쿼리 패턴
- CDC (Change Data Capture)  
  운영 DB의 변경 사항을 추출해 분석 DB에 실시간 반영.  
- 패스트 팔로워 (Fast Follower)  
    - 운영 DB = 리더, 분석 DB = 팔로워 -> 거의 실시간 동기화.  
    - 스트리밍 쿼리 패턴 분석 DB에서 변경 데이터 반영된 결과를 조회 
    -> 운영 DB 부하 없이 최신 통계/집계 가능.  
    - 운영 DB 직접 쿼리 문제  
    OLTP에 최적화 -> 무거운 분석 쿼리 실행 시 성능 저하·지연·충돌 발생.  
    - 장점: 운영 DB 영향 최소화, 준실시간 분석 가능.  
    Druid/BigQuery: 스트리밍 버퍼 + 컬럼 스토리지로 대규모 데이터 처리 유리.  
    - 한계: 본질적으로 배치형 SELECT 중심.  
    이벤트 기반 트리거/푸시는 부족 → 진정한 스트리밍 처리에는 한계.  


- 카파 아키텍처
    - 모든 데이터를 스트림으로 저장
    - 스트리밍 스토리지를 실시간 전송 계층이자, 과거 데이터를 검색하고 쿼리하는 데이터베이스로 취급하는 것.

### 2) 윈도, 트리거, 출력된 통계, 늦게 도착한 데이터
- 기존 배치 쿼리는 쿼리 엔진을 외부 옵저버(필요할 때만 불러오사 실행하는 외부 관찰자)로 취급하고 데이터 외부의 액터(외부 주체가 행동)가 쿼리를 실행한다.
- 스트리밍은 데이터 자체에서 직접 트리거되는 계산 개념을 지원함.
    - 버퍼에 일정 레코드 수가 수집되면 평균, 중앙값 통계 정보를 내보내거나 세션 닫힐때 요약 출력.


- 윈도는 동적 트리거로 처리되는 작업 배치. (시간을 기준으로 데이터를 모아 그룹핑하는 방법)
    - 세션 윈도 : 사용자의 활동 이벤트를 시간 간격 기준으로 묶어 비활성 시간이 일정 시간 이상 
    지속되면 세션을 닫고 늦게 도착한 이벤트까지 고려해 동적으로 세션을 관리하는 윈도 방식
    - 고정 시간 윈도 : 정해진 시간 간격마다 데이터를 모아 처리하는 스트리밍 윈도 방식. 
    배치 ETL 방식과 유사.
    - 슬라이딩 윈도 : 고정 길이의 윈도를 일정 간격으로 겹치게 이동시키며 이벤트를 그룹화하는 방식.
    조건부 트리거를 통해 결과 출력 시점을 유연하게 조정할 수 있음
    - 워터 마크 : 데이터가 설정된 시간 간격 내 있는지, 지연으로 간주되는지를 판단하기 위해 
    윈도에서 사용하는 임계값.


- 스트림과 다른 데이터의 결합
    - 기존 테이블 조인
        - 전통적인 방식처럼 데이터베이스에서 스트림으로 채워진 테이블과 다른 테이블을 단순히 조인
    - 보강(Enrichment)
        - 스트림 이벤트에 외부 데이터를 조인
        - 인메모리 DB, RDBMS, 객체 스토리지 등 다양한 소스를 참조해 이벤트를 보강
    - 스트림 간 조인
        - 조인 프로세서를 이용해 두 개 이상의 스트림을 직접 결합.
        - 문제: 스트림별 지연 시간 차이, 늦게 도착하는 이벤트 처리 필요
        - 해결: 스트리밍 버퍼를 두고 일정 시간 동안 이벤트를 보관, 해당 기간 안에 매칭되는 이벤트가 있으면 조인 처리


# 8.2 데이터 모델링

> 데이터 관리 (데이터 거버넌스 및 데이터 품질) 인기가 높아지면서 일관성 있는 비즈니스 로직 필요성이 커짐 -> 데이터 모델링이 중요하다는 인식 확산

## 8.2.1 데이터 모델이란? 
- 실제 세계와 연관되는 방식. 
- 조직의 프로세스, 정의, 워크플로 및 논리를 잘 반영하기 위해 데이터 구조화/표준화 반영


## 8.2.2 개념적, 논리적, 물리적 데이터 모델

### 1) 개념적 데이터 모델 
- 비즈니스 논리 및 규칙으로 스키마, 테이블, 필드와 같은 시스템 데이터 설명
- ER 다이어그램으로 시작해 엔티티 간 관계를 시각화

### 2) 논리적 데이터 모델
- 기본키와 외래키 매핑
- 각 컬럼의 유형에 대한 정보 추가 등 실제 구현 방법 반영

### 3) 물리적 데이터 모델
- 논리 모델 구현 방법을 정의함. 어떤 DB, 스키마 및 테이블 작성

> 가장 낮은 수준의 데이터 그레인(저장되고 쿼리되는 해상도)으로 모델링하기!

## 8.2.3 정규화
- 테이블과 열의 관계를 업격하게 분리해서 중복 배제하고 참조 무결성 보장
- 비정규화 > 제1정규형 > 제2정규형 > 제3정규형
    - 고유한 기본 키 : 행을 식별하는 단일 필드 / 여러 필드 집합
    - 부분 종속성 : 복합 키 중 하나만으로도 열을 유일하게 식별할 수 있는 경우
    - 전이 종속성 : 키가 아닌 필드가, 또 다른 키가 아닌 필드에 의존하는 경우
- 397p 정규화 단계


## 8.2.4 배치 분석 데이터 모델링 기술
- 원시 데이터는 다양한 형태지만 출력은 행과 열의 정형화된 데이터 모델로 가정해야한다.
- 이런 환경에서 여러 데이터 모델링 방식을 사용할 수 있다
- 기술들은 결합해 사용할 수 있다. 


### 1) 인먼
- 원천 시스템과 분석 시스템 분리를 위한 데이터 웨어하우스 
    - 주제 지향성 -> 주요 소스 데이터베이스와 정보 시스템으로 구성.
    - 통합 -> 원천 시스템의 정규화 구조와 유사하게 고도로 정규화된(3NF) 형태로 저장
    - 비휘발성
    - 시간 변이성
- 조직 전체 데이터를 세분화되고 고도로 정규화된 ER 모델로 통합
    - 엄격한 정규화 요건: 데이터 중복 최소화, 분산 방지, 분석 오류 감소
    - 다운스트림 데이터 마트: 데이터 웨어하우스에서 데이터를 가져와 변환 후 제공, 필요 시 비정규화


### 2) 킴벌
- 인번과 반대로 비정규화 수용. 
- 데이터 웨어하우스 자체에서 부서 또는 비즈니스 분석을 모델링하고 제공하도록 권장.
- 빠른 반복과 모델링이 가능하지만 데이터 통합이 느슨하고 중복과 복제가 발생.
- 팩트 테이블, 차원 테이블, 스타 스키마


#### 팩트 테이블
- 사실, 수량 등의 이벤트 테이블. 변경 불가하며 추가 전용
- 가능한 낮은 그레인으로 작성되어 있고, 테이블 내에서 집계 / 파생 작업 하지 않음

#### 차원 테이블
- 팩트 테이블에 저장된 이벤트의 참조 데이터, 속성 및 관계 컨텍스트 제공
    - 고객, 제품, 지역 같은 속성 정보. 시간이 지나면 바뀌는 값들 저장
- 차원 테이블이 시간이 지나며 바뀌는걸 어떻게 추적할지? SCD
    - 유형 1: 기존 값 덮어쓰기
    - 유형 2: 변경될 때마다 새로운 행을 생성해 전체 이력 유지
    - 유형 3: 새로운 행을 만드는 대신 새로운 컬럼(필드) 생성


#### 스타 스키마
- 팩트/차원 테이블 통합하기. 필요한 차원으로 둘러싸인 팩트 테이블
    - 조인 수가 적어 쿼리 성능 향상됨
    - 비즈니스 로직을 잘 반영함.
- 다운스트림 데이터마트, BI 도구에서 직접 보고서 모델링 가능. 
- 여러 스타 스티마에서 공유하는 차원을 간단히 맞춰진 차원 이라고 함.
    - 여러 스키마에 걸처 팩트 테이블 여럿을 결합할 수 있음


### 3) 데이터 볼트
- 원천 시스템 데이터의 속성에서 구조적 측면을 분리
- 원천 시스템의 데이터를 입력 전용 방식으로 소수의 특수 제작된 테이블에 직접 로드
- 데이터 모델은 민첩하고 유연하며 확장 가능하며 이를 충족하는게 주요 목표
- 비즈니스 데이터가 진화를 거듭하는 동안에도 데이터를 비즈니스에 최대한 밀접하게 연계해 유지
- 허브, 링크, 위성
    - 사용자가 허브를 쿼리하면 허브는 쿼리의 관련 속성을 포함하는 위성 테이블에 링크됨
- 데이터를 쿼리할 때 비즈니스 로직이 생성되고 해석됨
- 다른 모델링 기법과 함께 사용할 수 있음


#### 허브 테이블
- 데이터 볼트에 로드된 모든 고유한 비즈니스키의 레코드를 보관하는 중심 엔티티
- 해당 표준 필드 포함
    - 해시 키 (조인하는데 사용하는 기본 키)
    - 로드 날짜
    - 레코드 소스
    - 비즈니스 키
- 허브 데이터는 변경되지 않고 영구 유지됨
- 식별 가능한 비즈니스 요소가 무엇인지 아는 것이 중요


#### 링크 테이블
- 허브 간 비즈니스 키의 관계를 추적
- 다양한 허브의 데이터를 연결
- 기본 데이터가 바뀌면 링크를 바꿔주어 빠른 변경에 적용 가능

#### 위성
- 링크를 통해 연결된 허브들의 관계가 무엇을 의미하는지 알 수 있도록 하는 기술 속성


### 4) 넓은 비정규화 테이블
- 배경
    - 엄격한 모델링 접근 방식(김벌, 인먼)은 온프레미스 시절 리소스 제약 환경에서 개발됨
    - 클라우드의 인기로 스토리지 비용이 저렴해지면서 완화된 접근 방식이 보편화
    - 원천 및 분석 시스템에서 스키마 유연성으로 중첩 데이터(JSON 등) 인기
- 와이드 테이블은 고도로 비정규화되고 매우 광범위한 여러 필드의 집합으로, 일반적으로 컬럼형 데이터베이스에 생성
- 특징
    - 필드는 단일 값일 수도 있고 중첩된 데이터를 포함할 수도 있으며, 1개 또는 여러 개의 키와 함께 구성
    - 관계형 데이터베이스의 스키마 진화는 느리고 리소스를 많이 소모하지만, 컬럼형 데이터베이스는 메타데이터 변경으로 처리.
- 비판
    - 데이터를 혼합했을 때 비즈니스 논리가 손실될 수 있음. 배열 내 요소 갱신 시 성능 저하.
- 데이터 모델링에 관심이 없거나 더 많은 유연성이 필요한 경우, 또는 스트리밍 데이터에 적합


#### 데이터 모델링 하지 않는 경우의 고려사항
- 쿼리 결과 일관성은 어떻게 보장?
- 비즈니스 로직 정의가 있는지? 그래서 쿼리가 올바른 답을 도출 하는지?
- 원천 시스템이 쿼리 부하 감당할 수 있는지?


## 8.2.5 스트리밍 데이터 모델링
- 현재 상황: 무한하고 지속적인 특성 때문에 배치 기법 사용은 어려움
    - 데이터 웨어하우스에 무리를 주지 않으면서 천천히 변화하는 유형 2 차원을 지속해 갱신
- 일부는 데이터 스트리밍 모델링의 옵션으로 데이터 볼트를 제안
- 문제점
    - 스트림에는 이벤트 스트림과 CDC 두 가지 주요 유형이 존재하며, 대부분은 JSON과 같은 반정형 구조
    - 페이로드의 스키마가 즉흥적으로 변경될 수 있음
- 원천 시스템이 올바른 비즈니스 정의와 로직을 통해 올바른 데이터를 제공해야함
- 전망
    - 데이터가 실시간으로 생성되므로 원천 시스템과 분석 시스템을 인위적으로 분리하는 개념의 의미는 줄어들 수 있다.