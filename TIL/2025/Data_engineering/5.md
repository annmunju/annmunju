---
marp: true
title: 견고한 데이터 엔지니어링 (5장 요약)
description: 
author: annmunju
theme: default
paginate: true
---

# 견고한 데이터 엔지니어링
## 5장 요약

> 1단계
> 원천 시스템에서의 데이터 생성

---



1. 데이터 원천

2. 원천 시스템 : 주요 아이디어
1) 파일과 비정형 데이터
2) API
3) OLTP
    - ACID -> 원자성
    - 원자적 트랜젝션 
4) OLAP
    - 열기반. 대규모 대화형 분석 쿼리 지원 (많은 양 데이터를 사용자가 실시간처럼 빠르게 분석하고자 함. BI)
5) CDC
    - DB 발생 변경 이벤트 추출. NoSQL DB에 저장하기도 함
6) 로그
    - 로그 소스 / 로그 인코딩 / 로그 해상도 / 로그 지연시간
7) 데이터베이스 로그 ... 
-> 이거랑 CDC랑 좀 헷갈렸는데, DB 로그는 원본에서 발생한 모든 변경을 순차적으로 트랜젝션 로그에 기록 -> CDC는 로그를 tail/timestamp 단위로 읽어 로우레벨 이벤트로 변환한 후 큐/토픽(카프카나 Kinesis, Pub/Sub 같은 분산 시스템)에 게시하는 것임. 그럼 이 게시된 내용을 이벤트 스트림 전환되면 이거 읽어서 실시간 대응, 분석, 복제 등을 효율적으로 수행함.

8) CRUD
9) 입력 전용
    - 데이터를 원본 그대로 기록만 하고, 읽기(조회)는 다른 구조 또는 경로에서 수행하도록 설계된 패턴
10) 메시지와 스트림
| 구분     | 메시지 큐                     | 스트리밍 플랫폼                             |
| ------ | ------------------------- | ------------------------------------ |
| 소비 모델  | 파괴적 소비 (하나에게만 전달)         | 비파괴적 소비 (여러 소비자에서 독립적으로 처리)          |
| 데이터 보존 | 전송 후 삭제됨                  | 보존 기간 동안 유지되며 리플레이 가능                |
| 운영 패턴  | point‑to‑point (1:1)      | pub/sub (1\:N), 또는 다수 grp에서 병렬 처리 가능 |
| 처리 보장  | 하나만 처리 → 중복 없음            | at‑least‑once 또는 exactly‑once 처리 가능  |
| 통신 지연  | 낮지만 소비자 오프셋 관리 어려움        | low-latency & high‑throughput 실시간성   |
| 주 용도   | 단일 task 전달, command queue | 이벤트시계, 로그, 분석, 복제, 히스토리 관리 등         |
| 서비스 예시 | SQS, RabbitMQ, ActiveMQ | Kafka, Kinesis, Pub/Sub     |

11) 시간 유형
    - 이벤트 시간 (생성된 시점)
    - 수집 시간 (다른 위치로 이벤트가 언제 수집되었는지)
    - 처리 시간 (수집 시간 이후 데이터 처리)
    - 처리에 걸린 시간 (데이터 처리 소요 시간)

3. 원천 시스템의 실질적인 세부 사항
1) 데이터베이스
    - 데이터베이스 기술을 이해하기 위한 주요 고려사항 : DBMS, 조회, 쿼리 옵티마이저, 확장과 분산, 모델링 패턴, CRUD, 일관성
| #  | 개념 영역          | 정의 범위(요약)                                                  | FoDE 핵심 내용                                                                                      | 실무에서 왜 중요한가                                                |
|----|-------------------|------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------|
| ① | **DBMS**           | 데이터베이스 관리 시스템 (storage engine, query optimizer 포함)         | DBMS는 저장, 쿼리 계획, 복구, 인덱싱 등 핵심 컴포넌트 포함                                          | 데이터 저장/조직/검색 구조의 기초. 기술 선택 시 핵심 기준: row vs column-store |
| ② | **쿼리 옵티마이저** | SQL 등 쿼리 → 파싱 → 바이트코드 → 옵티마이저 → 실행                         | 쿼리의 생애 주기 설명, 옵티마이저가 실행 계획 생성 → 성능 최적화                                     | 쿼리 성능 향상(인덱스, 조인 순서, 리소스 플랜) → 비용 절감, 응답 속도 보장 |
| ③ | **확장 & 분산**    | 수평/수직 확장, 파티셔닝, 복제, shared-nothing/ shared-everything 아키텍처 | 확장성, 복제, 장애 복원성을 고려한 분산 설계. shared-nothing은 중복 없이 수평 확장 가능             | 데이터 볼륨 증가 대응, 부하 분산, 장애격리, 지리적 분산 구현에 필수     |
| ④ | **모델링 패턴**     | 개념/논리/물리 모델 → 정규화, 차원 모델, 데이터 볼트                           | 3단계 스키마 구조, 정규화(3NF), star/snowflake schema, Data Vault 모델 등 다양한 모델 제시           | OLTP에는 정규화, OLAP에는 차원 모델 적합. 데이터 변환/분석 성능 최적화 가능 |
| ⑤ | **CRUD**           | Create, Read, Update, Delete 작업 유형                         | OLTP 시스템은 CRUD 중심. 변경 이력은 insert-only로 수집되어 CDC 파이프라인 구성에 적합               | 트랜잭션 동작에 맞는 설계: 업데이트 빈도, 변경 이력 저장 방식 고려       |
| ⑥ | **일관성**          | ACID (강한 일관성) vs BASE (점진적 일관성)                          | OLTP는 ACID 기반. 분산 시스템에서는 eventual consistency와의 균형이 필요                             | 실시간 복제, 확장, 고가용성 설계 시 CAP 이론의 trade-off 고려 필수     |

    - 관계형 데이터베이스
    - 비관계형 데이터베이스 : NoSQL (Not only SQL)
        - 관계형 제약 조건을 해제하면 성능, 확장성, 스키마 유연성 높임. 관계형이 아닌 DB 전부를 의미함.
        - 키-값 쌍 저장소 (인메모리 형식의 Redis)
        - 도큐먼트 저장소
        - 와이드-컬럼 데이터베이스 (Cassandra, HBase, Bigtable 등) : 실시간 추천 시스템, 사용자 타임라인/이벤트 로그	등에 활용
        - 그래프 데이터베이스
        - 검색 데이터베이스 (Elastic Search)
        - 시계열 데이터베이스

2) API
    - REST
        - 각 호출은 독립적이며 추상화 수준은 개발자에 따라 달라짐
        - 데이터 수집 파이프라인시에 REST API 활용이 더 커짐
            - 데이터 공급자가 클라이언트 라이브러리를 제공
            - API와 상호작용하고 데이터 동기화를 관리하는 다양한 서비스와 오픈소스 라이브러리의 등장 
    - GraphQL 
        - 데이터의 쿼리 언어이며 REST API 대안
    - 웹훅
        - 이벤트 기반 데이터 전송 패턴 (지정된 이벤트 발생시 HTTP 엔드포인트 호출 트리거)
    - RPC와 gRPC
        - 분산 컴퓨팅에서 사용하는 원격 시스템 프로시저 호출 라이브러리

3) 데이터 공유 & 4) 서드파티 데이터 원천
    - 메타데이터를 기반으로 엑세스 중심으로 진행. (물리적 데이터 이동, 복제 없이 접근 가능한지 판단)
    - 정교한 권한 설정 필요 (특정 행, 열, 혹은 주요 데이터만 공유할 수 있음)
    - 
| 항목             | 의미                                                     |
| -------------- | ------------------------------------------------------ |
| **서드파티 데이터**   | **내가 직접 수집한 게 아닌, 다른 회사가 수집한 외부 데이터 자체** (데이터의 ‘성격’)   |
| **데이터 마켓플레이스** | **그런 서드파티 데이터를 사고팔거나 공유할 수 있게 해주는 플랫폼** (데이터의 ‘유통 경로’) |

5) 메시지 큐와 이벤트 스트리밍 플랫폼

4. 함께 작업할 대상

5. 드러나지 않는 요소가 원천 시스템에 미치는 영향
1) 보안
2) 데이터 관리
3) 데이터 옵스
4) 데이터 아키텍처
5) 오케스트레이션
5) 소프트웨어 엔지니어링

6. 결론

---

OLTP 시스템은 수많은 작고 빈번한 트랜잭션을 정확하게 처리해야 하므로,
ACID 특성을 지키는 데이터베이스가 필수적입니다
OLTP 시스템의 데이터 무결성과 신뢰성을 위해 ACID는 핵심 기준이며
ACID는 트랜잭션의 안정성과 신뢰성을 보장하는 4가지 원칙입니다

| 속성                        | 설명                                        | 비유                          |
| ------------------------- | ----------------------------------------- | --------------------------- |
| **A - 원자성 (Atomicity)**   | 하나의 트랜잭션은 **모두 실행되거나 전혀 실행되지 않아야 함**      | ATM 이체 중간에 끊기면 입금/출금 둘 다 취소 |
| **C - 일관성 (Consistency)** | 트랜잭션 전후로 데이터는 항상 **정해진 규칙(제약조건)을 만족**해야 함 | 재고 수량이 음수가 되면 안 됨           |
| **I - 고립성 (Isolation)**   | 동시에 여러 트랜잭션이 실행돼도 **서로 간섭하지 않아야 함**       | 두 사용자가 동시에 같은 좌석 예매 못하게     |
| **D - 지속성 (Durability)**  | 트랜잭션이 성공하면 결과는 **시스템 오류가 나도 보존되어야 함**     | 주문이 완료됐으면 서버 꺼져도 기록 유지      |


원자성의 기술적 처리 방식
| 방식               | 설명                              |
| ---------------- | ------------------------------- |
| **트랜잭션 로그**      | 수행 중인 작업을 기록하고, 실패 시 이전 상태로 되돌림 |
| **롤백(Rollback)** | 실패 시 자동으로 전체 작업 취소              |
| **커밋(Commit)**   | 모든 작업이 성공했을 때만 최종 반영            |
