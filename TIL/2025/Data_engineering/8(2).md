
# 견고한 데이터 엔지니어링
## 8장 요약 (2)

> 데이터 변환


# 8.3 변환

- 변환과 쿼리는 다르다. 
    - 지속성 : 쿼리는 필터링 및 조인 로직에 따라 검색 / 변환은 추가 변환 또는 쿼리를 통해 결과를 계속 사용할 수 있게 유지한다.
    - 복잡성 : 변환을 통해 복잡한 파이프라인 구축 가능

## 8.3.1 배치 변환

### 분산 조인 : 논리적 조인을 클러스터 내 개별 서버에서 실행되는 훨씬 작은 노드 조인으로 분할.
- 브로드캐스트 조인 : 작은 테이블을 큰 테이블을 분할한 것과 각각 조인해서 노드 조인을 수행. 작은 테이블을 왼쪽으로 이동시키는 조인 재정렬을 수행하고 이후에 left join 하면 성능이 대폭 개선됨
- 셔플 해시 조인 : 초기 파티셔닝을 기억해뒀다가(해시 스킴 이용) 분할해서 연산하고 나중에 다시 파티셔닝 할 때 사용

### ETL, ELT, 데이터 파이프라인
- 원천 시스템과 대상 시스템 제한으로 ETL 방식 유행
- DW, 스토리지 용량 증가, 데이터 레이크 등장으로 ELT로 진화
- 이제는 ETL, ELT 같은 도구로 표준화 할 필요 없으며 데이터 파이프라인을 구축할 때 적절한 기술을 사례별로 적용하는데 집중

### SQL과 코드 기반 변환 도구
- SQL은 선언형 언어이지만 잘 활용하면 복잡한 파이프라인에도 활용할 수 있다.
- 스파크에서 배치 변환을 위해 SQL을 피해야 하는 경우
    - SQL로 변환을 코딩 하기가 얼마나 어려운가?
    - 생성되는 SQL 코드는 어느 정도에 가독성과 유지보수가 가능한가?
    - 향후 조직 전체에 걸쳐 재사용 할 수 있도록 변환 코드 중 일부를 커스텀 라이브러리의 푸쉬해야 하는가
- SQL을 재활용 할 수 있는 방법
    - 테이블에 커밋하거나 뷰를 생성
    - 데이터 빌드 도구 DB T 등을 활용해 SQL문을 쉽게 재사용
- 스파크 및 기타 처리 프레임워크 최적화
    - 일찍 그리고 자주 필터링
    - 핵심 스파크 API의 의존, 스파크 네이티브 작업 방식을 이해하기
    - U D F의 주의
    - S Q L을 혼합 하는 것을 검토 하기

### 갱신 패턴
- 데이터 삭제와 제적재
- 입력 전용
- 삭제: 물리 삭제 / 논리 삭제 / 삭제 레코드 입력

### 갱신 입력과 병합
- 갱신 입력 병합 패턴은 원래 행 기반 데이터베이스용으로 설계 됐다
- 파일 기반 시스템은 갱신을 지원하지 않는다
- 분산 컬럼형 데이터 시스템이 네이티브 갱신 명령을 지원 하더라도 병합에는 큰 비용이 발생 한다
- 그러니 갱신 또는 병합 빈도의 유의 하자

### 스키마 갱신
- 열 기반 시스템은 데이터 갱신은 어렵지만 스키마 갱신은 쉽다
- 반전 형 데이터에 대한 옵션
    - 평면화된 필드
    - 평면화된 데이터

### 데이터 랭글링
- 지저분하고 잘못된 형식의 데이터를 깨끗한 데이터로 변환 하는 작업

### 비즈니스 로직과 파생 데이터
- 비즈니스 로직을 매트 계층의 적용하되 데이터 웨어하우스 또는 기타 도구를 활용해 계산 부하가 높은 작업을 수행

### 맵 리듀스
- 테이블 데이터는 데이터 블록의 여러 노드의 분산 됨
- 맵 리듀 스 잡은 블록 당 하나의 맵 테스크를 생성

## 8.3.2 

### 데이터 가상화

## 8.3.3 스트리밍 변환과 처리

### 기본
- 다운 스트림 사용을 위해 데이터를 준비 하기 위한 목표로 스트리밍 변환을 수행함

### 변환과 쿼리는 연속체

### 스트리밍 DAG
- 여러 가지 데이터 스트림을 표준 형식으로 전처리 하기 위한 도구로 사용

### 마이크로 배치 VS 진정한 스트리밍
- 한 번에 하나의 이벤트를 처리 하도록 할 것인가 아니면 소규모의 마이크로 배치로 처리 할 것인가?
    - 필요한데 필요한 만큼 이용하자

## 8.4 함께 일할 담당자

### 8.4.1 Upstream 이해관계자
- 관련 된 비즈니스 로직 및 정의를 파악해야 한다
- 원천 시스템의 데이터 모델 변경에 대한 양방향 커뮤니케이션이 필요하다

### 8.4.2 다운 스트림 이해관계자
- 성능 측면에서 가장 비효율적인 방법으로 커리를 실행 해야 한다
- 데이터가 최고 품질과 완전성을 가지고 있는 유용함을 제공 해야 한다

## 8.5 드러나지 않는 요소

### 8.5.1 보안
- 데이터베이스에 대한 공격 벡터의 주의 하자
- 자격 증명을 숨김 상태로 유지 하자

### 8.5.2 데이터 관리
- 변환 단계에서는 데이터의 관리가 매우 중요
- 데이터의 각 비즈니스 정의에 맞는 몇 명 규칙에 모두가 동의 하는지 확인 할 것
    - 사용자가 데이터 카탈로그에서 필드가 생성된 시점 데이터를 셋을 유지 관리 하는 사용자 및 기타 관련 정보를 명확하게 확인 하도록 해야 함

- 정의적 정확성
    - 변환이 예상되는 비즈니스 논리의 부합 하는가?
    - 비즈니스 로직을 런타임에서 적용 하는 대신 변환 계층 이전에 독립 실행 형 단계로 유지 하는 것은 어떨까?

- 사용중인 데이터의 결함이 없는지 확인 할 것
    - MDM

- 데이터 집합이 동일한 경로에서 어떻게 파생 되었는지 알기 위한 데이터 계보
    
- 데이터 모델 및 변환에 대한 법령 준수: 마스킹 또는 난독화

### 8.5.3 데이터 옵스
- 데이터의 품질
- 시스템 성능

- 싸쓰 기반 분석 데이터베이스 로의 전환은 데이터 소비의 비용 프로파일을 변화시킴
    - 성능 최적화 만큼 비용 최적화

### 8.5.4 데이터 아키텍처
- 데이터 팀은 아키텍처 선택이 쿼리 성능에 어떤 영향을 미치는지 파악 해야 한다

### 8.5.5 오케스트레이션

### 8.5.6 소프트웨어 엔지니어링
- 네이티브 함수 VS U D F
- D B T 같은 분석 엔지니어링 변환 도구
- GUI 기반 로우 코드를 통한 변환 워크플로

## 8.6 결론
- 데이터의 변환은 비즈니스의 가치와 ROI를 더한다
