<!-- 57p -->

# 2.2 디자인 패턴 1: 특징 해시

## 문제
- 불완전한 어휘 : 병원의 일련번호, 담당의사 ID 등이 카테고리로 사용되는 경우
- 카디널리티로 인한 모델 크기 : 위와 같은 예시는 높은 카디널리티로 모델이 커질 수 있음
- 콜드 스타트 : 새로운 병원, 의사 고용 같은 경우 기존 모델이 예측하기 어려움

## 솔루션
1. 카테고리 입력을 문자열로 변환
2. 문자열에 대한 결정론적 및 이식 가능한 해시 알고리즘(대표적으로 팜 핑거프린트) 호출
3. 해시 결과를 원하는 버킷 수로 나누고 나머지를 취하기

## 작동 원리
- 어휘 외 입력 : 학습 데이터에 없어도 해시된 특징값을 받을 수 있음. 버킷은 수많은 카테고리 데이터를 정해진 몇 개의 그룹으로 묶어주는 그릇. 모델은 개별 데이터가 아닌 이 그룹(버킷)의 특징을 학습함으로써, 메모리를 아끼고 처음 보는 데이터에도 유연하게 대처할 수 있게 됨. 해당 버킷의 수를 잘 선택해서 사용하는 것이 필요.
- 큰 카디널리티 : 모든 케이스를 수치로 변형하는 것이 아니라서 해겨로디지만 너무 적은 해시 버킷 수는 손실이 발생할 수 있음
- 콜드 스타트 : 해시 버킷에서 예측을 가져와서 일부 해결된다.

## 트레이드오프와 대안
- 버킷 충돌 : 동일한 버킷값이어도 되는 경우에만 특징 해시 사용 가능. 
- 왜도 : 높은 경우에 정확도 손실이 심각해짐. 

- 대안
    - 특징 집계 : 버킷 수가 너무 적어 버킷 충돌 생기거나, 왜도가 높은 경우 모델에 대한 입력으로 특징 집계를 사용하는것이 도움이 될 수 있음. 
    - 하이퍼파라미터 튜닝 : 버킷 수를 결정할 때 하이퍼파라미터로 취급해 조율

- 암호화 해시 X : 핑거프린트 해시 + 나머지 연산으로 특징 해시를 사용할 것.
    - 그냥 나머지 연산 없이? -> 가짜 상관관계 문제 : 우연히 같은 패턴을 가진 문자열로 데이터를 학습. 본질적인 문제와 상관없이 문자열 패턴으로 학습된 예측 결과는 해싱 방법이 생성한 우연한 패턴을 학습할 수 있음.
    - MD5 같은 암호화 해시? 보통 암호화 해시는 솔트가 들어가서 값이 항상 같지 않음(비결정론적). 일부러 계산 느리게 구현함. 단방향 해시이므로 서로 다른 입력이 같은 결과를 낼수도 있음. (암호화 해시의 특징)

- 연산의 순서 중요
- 빈 해시 버킷 : 버킷 중 하나가 비어있을 수 있음. 그렇기 때문에 해시된 특징 열을 사용할 때 빈 버킷과 관련된 가중치가 거의 0이 될 수 있게 L2 정규화 사용하는 것이 좋다.