- 성능 개선 및 트랜잭션



- C(일관성) A(가용성) P(파티셔닝) 이론 -> PACELE (파셀) 이론
	- 분산시스템에서 CA는 같이 가져가기 힘듦
	- ACID 데이터베이스 : 산성 데이터베이스 : 일관성을 가져감 
		- RDBM
	- BASE 데이터베이스 : 염기성 데이터베이스처럼 : 가용성을 가져감
		- NoSQL (몽고DB, Redis, DynamoDB, Couchbase)

- 단일 객체와 다중 객체의 연산
	- 단일객체 연산시 문서 형태의 DB의 경우,
		- 1단계 커밋
		- 해당 문서에 어떤 단계로 진행하고 있는지 기록.
	- 다중객체 연산시 문서 형태의 DB의 경우,
		- 2단계 커밋
		- 문서를 따로 만들어서 해당 문서에 누가 누구에게 보내줄 것인지, 어떤 작업을 얼만큼 할건지 단계별로 진행하고, 동시에 진행시키기. 그리고 완료하면 업데이트하기.

---

## 완화된 격리 수준

### 커밋 후 읽기
### 스냅숏 격리와 반복 읽기
### 갱신 손실 방지
### 쓰기 스큐와 팬텀
- 미묘한 충돌 상황. 명시된 제약조건을 어기는 업데이트 상황. 
- 쓰기 스큐 예시
	- 회의실 예약 시스템
	- 사용자명 획득 . 동시에 같은 사용자명으로 계정 생성 시도
- 추가하는 경우라서, 이전 질의가 반환하는 것이 없으면 잠글 수 없다.
- 충돌 구체화
	- 회의실 예약의 경우 회의실과 시간 범위에 대한 조합을 미리 정의. 잠금 역할을 하는 예약을 확인.

### 직렬성
- 동시성이 없이 한 번에 하나씩 직렬로 실행될때 보장.
- 모든 경쟁 조건을 막아준다.

### 실제적인 직렬 실행
- 상당히 최근에서야 단일 스레드 루프에서 트랜잭션 실행 가능하게 됨
	- 램 가격 저렴해짐
	- OLTP 트랜잭션이 짧고 실행하는 읽기 쓰기 개수가 적은걸 알아서
	- 분석질의는 전형적으로 읽기 전용이라 직렬 실행 루프 밖에서 일관된 스냅숏 실행
- 트랜잭션을 스토어드 프로시저 안에 캡슐화
	- 다중 구문 트랜잭션 쓰지 않고 한번에 "스토어드 프로시저" 형태로 데이터 베이스에 미리 제출
		- "스토어드 프로시저" : 데이터 베이스 안에서 로직의 묶음으로 한번에 다 처리 (postsql은 없다.)
			- Redis (메모리단에서 하니까 빨라서 직렬) - 루아 
- 장단점
	- 각각 다른 언어를 사용
	- 코드 관리 / 디버깅 어렵다
	- 앱서버보다 DB서버가 성능에 민감. (부하)
- 파티셔닝
	- 쓰기 처리량이 많으면 단일 쓰레드가 병목을 가져올 수 있음 -> 여러 CPU 사용으로 확장하기 위해 데이터 파티셔닝
	- 코디네이션 오버헤드가 있어서 단일보다 엄청 느려
	- 데이터 구조 따라서 파티셔닝 난이도도 달라짐


- AB180 go로 DB 만들 https://news.hada.io/topic?id=13821
### 2단계 잠금(2PL)


